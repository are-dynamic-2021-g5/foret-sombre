{
 "cells": [
  {
   "cell_type": "markdown",
   "id": "dominant-ticket",
   "metadata": {},
   "source": [
    "# ARE Forêt Sombre Historique Code\n",
    "\n",
    "## Introduction\n",
    "\n",
    "Ce notebook a été créé pour montrer l'évolution et les stratégies adoptées dans la conception de la simulation que nous avons dévellopée."
   ]
  },
  {
   "cell_type": "markdown",
   "id": "settled-fields",
   "metadata": {},
   "source": [
    "### Premier test avec pygame\n",
    "\n",
    "command d'install : pip install pygame\n",
    "\n",
    "La première idée venue a été celle d'utiliser la library moteur de jeu qui permet d'accéder simplement à une interface graphique. C'est à l'origine un moteur de jeu-vidéo qui permet notament de simuler facilement des intéractions physique : collision, mouvement sur un plan 2D et 3D etc...\n",
    "\n",
    "Dans un premier temps, afin de découvrir les différentes possibilitées que cette librairy apporte nous avons décidé de créer différents type de signaux qui pourrait servir à simuler la communication inter-civilisations. \n",
    "\n",
    "Deux types de signaux sont conceptualisés : \n",
    "- Multidirectionnels rectiligne uniforme (en cercle)\n",
    "- Multidirectionnels rectiligne individualisés (cercle en nuage de points indépendants)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "dental-motivation",
   "metadata": {},
   "source": [
    "##### En \"cercle\""
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "id": "mineral-porter",
   "metadata": {},
   "outputs": [
    {
     "ename": "ModuleNotFoundError",
     "evalue": "No module named 'pygame'",
     "output_type": "error",
     "traceback": [
      "\u001b[0;31m------------------------------------------------------------------------\u001b[0m",
      "\u001b[0;31mModuleNotFoundError\u001b[0m                    Traceback (most recent call last)",
      "\u001b[0;32m<ipython-input-1-c2049742582b>\u001b[0m in \u001b[0;36m<module>\u001b[0;34m\u001b[0m\n\u001b[0;32m----> 1\u001b[0;31m \u001b[0;32mimport\u001b[0m \u001b[0mpygame\u001b[0m \u001b[0;32mas\u001b[0m \u001b[0mpg\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[0m\u001b[1;32m      2\u001b[0m \u001b[0;32mimport\u001b[0m \u001b[0mrandom\u001b[0m\u001b[0;34m,\u001b[0m \u001b[0mmath\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m      3\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m      4\u001b[0m \u001b[0mpg\u001b[0m\u001b[0;34m.\u001b[0m\u001b[0minit\u001b[0m\u001b[0;34m(\u001b[0m\u001b[0;34m)\u001b[0m\u001b[0;34m\u001b[0m\u001b[0;34m\u001b[0m\u001b[0m\n\u001b[1;32m      5\u001b[0m \u001b[0;34m\u001b[0m\u001b[0m\n",
      "\u001b[0;31mModuleNotFoundError\u001b[0m: No module named 'pygame'"
     ]
    }
   ],
   "source": [
    "import pygame as pg\n",
    "import random, math\n",
    "\n",
    "pg.init()\n",
    "\n",
    "WIDTH, HEIGHT = 500, 500\n",
    "WIN = pg.display.set_mode((WIDTH, HEIGHT))\n",
    "\n",
    "BLACK = 0, 0, 0\n",
    "WHITE = 255, 255, 255\n",
    "RED = 255, 0, 0\n",
    "GREEN = 0, 255, 0\n",
    "BLUE = 0, 0, 255\n",
    "YELLOW = 255, 255, 0\n",
    "\n",
    "FPS = 60\n",
    "NB_CIVS = 10\n",
    "NB_STARS = 5\n",
    "\n",
    "class Civ:\n",
    "\tdef __init__(self, pos, classe=1, color=BLUE, signal_range=200):\n",
    "\t\tself.classe = classe\n",
    "\t\tself.pos = pos\n",
    "\t\tself.x = pos[0]\n",
    "\t\tself.y = pos[1]\n",
    "\t\tself.color = color\n",
    "\t\tself.size = 10\n",
    "\n",
    "\t\t#signal\n",
    "\t\tself.signal = None\n",
    "\t\tself.signal_pos = None\n",
    "\t\tself.signal_type = 'dots'\n",
    "\t\tself.signal_accuracy = 100\n",
    "\t\tself.signal_size = 0\n",
    "\t\tself.signal_range = signal_range\n",
    "\t\tself.signal_speed = 1\n",
    "\t\tself.get_signal = False\n",
    "\n",
    "\t\t#detection\n",
    "\t\tself.detected_civs = []\n",
    "\t\tself.is_detected = False\n",
    "\n",
    "\tdef draw(self):\n",
    "\t\tpg.draw.circle(WIN, self.color, self.pos, self.size) \n",
    "\n",
    "\tdef activate_signal(self):\n",
    "\t\t#créer le signal en calculant les coordonnées requises\n",
    "\t\tself.get_signal = True\n",
    "\t\tself.color = GREEN\n",
    "\n",
    "\tdef deativate_signal(self, reset=True):\n",
    "\t\tself.get_signal= False\n",
    "\t\tself.color = BLUE\n",
    "\t\tif reset: self.signal_size = 0\n",
    "\n",
    "\tdef update_signal(self):\n",
    "\t\tif self.signal_range <= self.signal_size:\n",
    "\t\t\tself.signal_size = 0\n",
    "\t\telse:\n",
    "\t\t\tself.signal_size += 1\n",
    "\t\tsignal = pg.draw.circle(WIN, WHITE, self.pos, self.signal_size, width=1)\n",
    "\n",
    "class Star:\n",
    "\n",
    "\tdef __init__(self, pos, size=20, color=YELLOW):\n",
    "\t\tself.pos = pos\n",
    "\t\tself.x = pos[0]\n",
    "\t\tself.y = pos[1]\n",
    "\n",
    "\t\tself.size = size\n",
    "\t\tself.color = color\n",
    "\n",
    "\t\tself.is_obstruing = []\n",
    "\n",
    "\tdef draw(self):\n",
    "\t\tpg.draw.circle(WIN, self.color, self.pos, self.size)\n",
    "\n",
    "def draw_window():\n",
    "\tWIN.fill(BLACK)\n",
    "\tdraw_scale(50) \n",
    "\n",
    "def init_civs():\n",
    "\trandom.seed(1)\n",
    "\tglobal civs\n",
    "\tcivs = []\n",
    "\tfor i in range(NB_CIVS):\n",
    "\t\trd_x, rd_y = random.randint(0, 500), random.randint(0, 500)\n",
    "\t\tcivs.append(Civ((rd_x, rd_y)))\n",
    "\n",
    "def init_stars():\n",
    "\trandom.seed(3)\n",
    "\tglobal stars\n",
    "\tstars = []\n",
    "\tfor i in range(NB_STARS):\n",
    "\t\trd_x, rd_y = random.randint(0, 500), random.randint(0, 500)\n",
    "\t\tstars.append(Star((rd_x, rd_y)))\n",
    "\n",
    "def draw_civs():\n",
    "\tfont = pg.font.SysFont(\"arial\", 14)\n",
    "\tfor i in range(len(civs)):\n",
    "\t\tcivs[i].draw()\n",
    "\t\timg = font.render(str(i), True, WHITE)\n",
    "\t\tWIN.blit(img, civs[i].pos)\n",
    "\n",
    "def draw_stars():\n",
    "\tfont = pg.font.SysFont(\"arial\", 14)\n",
    "\tfor i in range(len(stars)):\n",
    "\t\tstars[i].draw()\n",
    "\t\timg = font.render(str(i), True, BLACK)\n",
    "\t\tWIN.blit(img, stars[i].pos)\n",
    "\n",
    "def draw_scale(scale_al):\n",
    "\t# 1:10 -> 1px = 10 al\n",
    "\tpg.draw.line(WIN, WHITE, (430, 480), (480, 480))\n",
    "\tfont = pg.font.SysFont(\"arial\", 14)\n",
    "\timg = font.render(str(scale_al), True, WHITE)\n",
    "\tWIN.blit(img, (448, 482))\n",
    "\n",
    "def check_detection():\n",
    "\tfor i in range(len(civs)):\n",
    "\t\tfor c in range(len(civs)):\n",
    "\t\t\tif i != c:\n",
    "\t\t\t\td = math.sqrt((civs[i].x-civs[c].x)**2 + (civs[i].y-civs[c].y)**2)\n",
    "\t\t\t\tif civs[i].signal_size >= d and not c in civs[i].detected_civs:\n",
    "\t\t\t\t\tcivs[i].detected_civs.append(c)\n",
    "\t\t\t\t\tprint(i, \"has detected\", c)\n",
    "\t\t\t\t\tcivs[c].is_detected = True\n",
    "\t\t\t\t\tcivs[c].color = RED\n",
    "\t\tfor s in range(len(stars)):\n",
    "\t\t\td = math.sqrt((civs[i].x-stars[s].x)**2 + (civs[i].y-stars[s].y)**2)\n",
    "\t\t\tif civs[i].signal_size >= d:\n",
    "\t\t\t\tstars[s].is_obstruing.append(civs[i].pos)\t\n",
    "\n",
    "def draw_dotcircle(pos, acc):\n",
    "\tdots = []\n",
    "\tfor i in range(acc):\n",
    "\t\tpass\n",
    "\treturn dots\n",
    "\t\n",
    "def main():\n",
    "\n",
    "\tclock = pg.time.Clock()\n",
    "\trun = True\n",
    "\n",
    "\tinit_civs()\n",
    "\tinit_stars()\n",
    "\n",
    "\twhile run:\n",
    "\t\tclock.tick(FPS)\t\n",
    "\t\tfor event in pg.event.get():\n",
    "\t\t\tif event.type == pg.QUIT:\n",
    "\t\t\t\trun = False\n",
    "\n",
    "\t\tdraw_window()\n",
    "\t\tdraw_civs()\n",
    "\t\tdraw_stars()\n",
    "\n",
    "\t\tif not civs[0].get_signal and not civs[1].get_signal:\n",
    "\t\t\tcivs[0].activate_signal()\n",
    "\t\t\tcivs[1].activate_signal()\n",
    "\n",
    "\t\tcivs[0].update_signal()\n",
    "\t\tcivs[1].update_signal()\n",
    "\n",
    "\t\tcheck_detection()\n",
    "\n",
    "\t\tpg.display.flip()\n",
    "\tpg.quit()\n",
    "\n",
    "if __name__ == \"__main__\":\n",
    "\tmain()"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "latest-wallace",
   "metadata": {},
   "source": [
    "##### En \"Nuage de points\""
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "radio-looking",
   "metadata": {},
   "outputs": [],
   "source": [
    "import pygame as pg\n",
    "import random, math\n",
    "\n",
    "pg.init()\n",
    "\n",
    "WIDTH, HEIGHT = 500, 500\n",
    "WIN = pg.display.set_mode((WIDTH, HEIGHT))\n",
    "\n",
    "BLACK = 0, 0, 0\n",
    "WHITE = 255, 255, 255\n",
    "RED = 255, 0, 0\n",
    "GREEN = 0, 255, 0\n",
    "BLUE = 0, 0, 255\n",
    "YELLOW = 255, 255, 0\n",
    "\n",
    "FPS = 20\n",
    "NB_CIVS = 10\n",
    "NB_STARS = 5\n",
    "\n",
    "class Civ:\n",
    "\tdef __init__(self, pos, classe=1, color=BLUE, signal_range=200):\n",
    "\t\tself.classe = classe\n",
    "\t\tself.pos = pos\n",
    "\t\tself.x = pos[0]\n",
    "\t\tself.y = pos[1]\n",
    "\t\tself.color = color\n",
    "\t\tself.size = 5\n",
    "\n",
    "\t\t#signal\n",
    "\t\tself.signal_type = 'dots'\n",
    "\t\tself.signal_accuracy = 100\n",
    "\t\tself.signal_number = self.signal_accuracy\n",
    "\t\tself.signal_size = 0\n",
    "\t\tself.signal_range = signal_range\n",
    "\t\tself.signal_speed = 1\n",
    "\t\tself.get_signal = False\n",
    "\t\tself.signal = []\n",
    "\n",
    "\n",
    "\t\t#detection\n",
    "\t\tself.detected_civs = []\n",
    "\t\tself.is_detected = False\n",
    "\n",
    "\tdef draw(self):\n",
    "\t\tpg.draw.circle(WIN, self.color, self.pos, self.size)\n",
    "\n",
    "\tdef init_signal(self):\n",
    "\t\tfor i in range(self.signal_accuracy):\n",
    "\t\t\tself.signal.append((i, pg.draw.circle(WIN, WHITE, (self.x, self.y), 2)))\n",
    "\n",
    "\tdef draw_signal(self):\n",
    "\t\tfor i in range(len(self.signal)):\n",
    "\t\t\tindex, _ = self.signal[i]\n",
    "\t\t\tsignal_x = self.signal_size*math.cos(2*math.pi*index/self.signal_accuracy)+self.x\n",
    "\t\t\tsignal_y = self.signal_size*math.sin(2*math.pi*index/self.signal_accuracy)+self.y\n",
    "\t\t\tself.signal[i] = (indfrom mesa.visualization.modules import CanvasGrid\n",
    "            pg.draw.circle(WIN, WHITE, (signal_x, signal_y), 2))\n",
    "\n",
    "\tdef update_signal(self):\n",
    "\t\tif self.signal_size >= self.signal_range:\n",
    "\t\t\tself.signal_size = 0\n",
    "\t\t\tself.init_signal()\n",
    "\t\telse:\n",
    "\t\t\tself.signal_size += 1\n",
    "\t\tself.draw_signal()\n",
    "\n",
    "\tdef check_signal_collision(self, Star_list, destroy=True):\n",
    "\t\tfor index, srect in self.signal:\n",
    "\t\t\tfor j in range(len(Star_list)):\n",
    "\t\t\t\tif pg.Rect.colliderect(srect, Star_list[j].rect):\n",
    "\t\t\t\t\tfor i in range(len(self.signal)):\n",
    "\t\t\t\t\t\tif self.signal[i][0] == index:\n",
    "\t\t\t\t\t\t\tself.signal.pop(i)\n",
    "\t\t\t\t\t\t\tbreak\n",
    "\n",
    "class Star:\n",
    "\n",
    "\tdef __init__(self, pos, size=20, color=YELLOW):\n",
    "\t\tself.pos = pos\n",
    "\t\tself.x = pos[0]\n",
    "\t\tself.y = pos[1]\n",
    "\n",
    "\t\tself.size = size\n",
    "\t\tself.color = color\n",
    "\t\tself.rect = None\n",
    "\n",
    "\t\tself.is_obstruing = []\n",
    "\n",
    "\tdef draw(self):\n",
    "\t\tself.rect = pg.draw.circle(WIN, self.color, self.pos, self.size)\n",
    "\n",
    "def draw_window():\n",
    "\tWIN.fill(BLACK)\n",
    "\tdraw_scale(50) \n",
    "\n",
    "def init_civs():\n",
    "\trandom.seed(1)\n",
    "\tglobal civs\n",
    "\tcivs = []\n",
    "\tfor i in range(NB_CIVS):\n",
    "\t\trd_x, rd_y = random.randint(0, 500), random.randint(0, 500)\n",
    "\t\tcivs.append(Civ((rd_x, rd_y)))\n",
    "\n",
    "def init_stars():\n",
    "\trandom.seed(3)\n",
    "\tglobal stars\n",
    "\tstars = []\n",
    "\tfor i in range(NB_STARS):\n",
    "\t\trd_x, rd_y = random.randint(0, 500), random.randint(0, 500)\n",
    "\t\tstars.append(Star((rd_x, rd_y)))\n",
    "\n",
    "def draw_civs():\n",
    "\tfont = pg.font.SysFont(\"arial\", 14)\n",
    "\tfor i in range(len(civs)):\n",
    "\t\tcivs[i].draw()\n",
    "\t\timg = font.render(str(i), True, WHITE)\n",
    "\t\tWIN.blit(img, civs[i].pos)\n",
    "\n",
    "def draw_stars():\n",
    "\tfont = pg.font.SysFont(\"arial\", 14)\n",
    "\tfor i in range(len(stars)):\n",
    "\t\tstars[i].draw()\n",
    "\t\timg = font.render(str(i), True, BLACK)\n",
    "\t\tWIN.blit(img, stars[i].pos)\n",
    "\n",
    "def draw_scale(scale_al):\n",
    "\t# 1:10 -> 1px = 10 al\n",
    "\tpg.draw.line(WIN, WHITE, (430, 480), (480, 480))\n",
    "\tfont = pg.font.SysFont(\"arial\", 14)\n",
    "\timg = font.render(str(scale_al), True, WHITE)\n",
    "\tWIN.blit(img, (448, 482))\n",
    "\n",
    "def check_detection():\n",
    "\tfor i in range(len(civs)):\n",
    "\t\tfor c in range(len(civs)):\n",
    "\t\t\tif i != c:\n",
    "\t\t\t\td = math.sqrt((civs[i].x-civs[c].x)**2 + (civs[i].y-civs[c].y)**2)\n",
    "\t\t\t\tif civs[i].signal_size >= d and not c in civs[i].detected_civs:\n",
    "\t\t\t\t\tcivs[i].detected_civs.append(c)\n",
    "\t\t\t\t\t# print(i, \"has detected\", c)\n",
    "\t\t\t\t\tcivs[c].is_detected = True\n",
    "\t\t\t\t\tcivs[c].color = RED\n",
    "\t\tfor s in range(len(stars)):\n",
    "\t\t\td = math.sqrt((civs[i].x-stars[s].x)**2 + (civs[i].y-stars[s].y)**2)\n",
    "\t\t\tif civs[i].signal_size >= d:\n",
    "\t\t\t\tstars[s].is_obstruing.append(civs[i].pos)\t\n",
    "\n",
    "def draw_dotcircle(pos, acc):\n",
    "\tdots = []\n",
    "\tfor i in range(acc):\n",
    "\t\tpass\n",
    "\treturn dots\n",
    "\t\n",
    "def main():\n",
    "\n",
    "\tclock = pg.time.Clock()\n",
    "\trun = True\n",
    "\n",
    "\tinit_civs()\n",
    "\tinit_stars()\n",
    "\n",
    "\tcivs[4].init_signal()\n",
    "\n",
    "\twhile run:\n",
    "\t\tclock.tick(FPS)\t\n",
    "\t\tfor event in pg.event.get():\n",
    "\t\t\tif event.type == pg.QUIT:\n",
    "\t\t\t\trun = False\n",
    "\n",
    "\t\tdraw_window()\n",
    "\t\tdraw_civs()\n",
    "\t\tdraw_stars()\n",
    "\n",
    "\t\tcivs[4].update_signal()\n",
    "\n",
    "\t\tcivs[4].check_signal_collision(stars)\n",
    "\n",
    "\t\tpg.display.flip()\n",
    "\tpg.quit()\n",
    "\n",
    "if __name__ == \"__main__\":\n",
    "\tmain()"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "variable-harassment",
   "metadata": {},
   "source": [
    "#### Remarque\n",
    "\n",
    "Pygame n'est absolument pas le module adapté pour ce que nous cherchons à faire, bien trop orientés moteur de jeu/physique qu'il ne le faut pour ce projet."
   ]
  },
  {
   "cell_type": "markdown",
   "id": "variable-gather",
   "metadata": {},
   "source": [
    "### Second test avec Mesa ABM (agent base modelling)\n",
    "\n",
    "command d'install : pip install mesa\n",
    "\n",
    "Mesa ABM, une libraire python basée sur les modèles à base d'agent semble beaucoup plus adapté à une simulation simple et efficace de la théorie de la forêt sombre. Elle permet de faire évoluer les différents agents, dans notre cas, les différentes civilisations en fonction d'une timeline (Model.schedule) et offre une grande simplicité de vizualisation avec une page web sur laquelle s'affiche nos données."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "lovely-fields",
   "metadata": {},
   "outputs": [],
   "source": [
    "from mesa import Agent, Model\n",
    "from mesa.time import RandomActivation\n",
    "from mesa.space import MultiGrid\n",
    "from mesa.datacollection import DataCollector\n",
    "\n",
    "import random\n",
    "\n",
    "\n",
    "class CivAgent(Agent):\n",
    "\n",
    "    def __init__(self, unique_id, model):\n",
    "        super().__init__(unique_id, model)\n",
    "        self.ems_ablt = random.randrange(10)  # Capacité à émettre des signaux\n",
    "        # Capacité à recevoir des signaux\n",
    "        self.rcpt_ablt = random.randrange(10)\n",
    "        # Type de civilisation : Pacifique ou Aggressive\n",
    "        self.type = bool(random.getrandbits(1))\n",
    "        self.tech_lvl = random.randrange(10)  # Niveau technologique\n",
    "\n",
    "    def step(self):\n",
    "        print(\"Agent {} initialized\".format(self.unique_id),\n",
    "              \"Emission ability : {}\".format(self.ems_ablt),\n",
    "              \"Reception ability : {}\".format(self.rcpt_ablt),\n",
    "              \"Tech lvl : {}\".format(self.tech_lvl),\n",
    "              \"Type : {}\".format(self.type))\n",
    "\n",
    "\n",
    "class CivModel(Model):\n",
    "\n",
    "    def __init__(self, N, width, height):\n",
    "        self.num_agents = N\n",
    "        self.grid = MultiGrid(width, height, True)\n",
    "        self.schedule = RandomActivation(self)  # Créer une timeline\n",
    "\n",
    "        for i in range(self.num_agents):\n",
    "\n",
    "            agent = CivAgent(i, self)\n",
    "            self.schedule.add(agent)  # ajoute N agent à la timeline\n",
    "            # positionne aléatoirement l'agent sur la grille\n",
    "            x = self.random.randrange(self.grid.width)\n",
    "            y = self.random.randrange(self.grid.height)\n",
    "            self.grid.place_agent(agent, (x, y))\n",
    "\n",
    "    def step(self):\n",
    "        self.schedule.step()"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "mighty-commission",
   "metadata": {},
   "source": [
    "L'\"environnement intéractif\" (le main()) :"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "threatened-collins",
   "metadata": {},
   "outputs": [],
   "source": [
    "from DfModel import CivModel\n",
    "\n",
    "empty_model = CivModel(11)\n",
    "empty_model.step()"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "racial-couple",
   "metadata": {},
   "source": [
    "Pour visualiser :"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "familiar-parcel",
   "metadata": {},
   "outputs": [],
   "source": [
    "from mesa.visualization.modules import CanvasGrid\n",
    "from mesa.visualization.ModularVisualization import ModularServer\n",
    "\n",
    "from DfModel import CivModel\n",
    "\n",
    "# Grid design\n",
    "def agent_portrayal(agent):\n",
    "\tportrayal = {\"Shape\": \"circle\",\n",
    "\t\t\t\t \"Color\": \"red\", \n",
    "\t\t\t\t \"Filled\": \"true\",\n",
    "\t\t\t\t \"Layer\": 0,\n",
    "\t\t\t\t \"r\": 0.5}\n",
    "\treturn portrayal \n",
    "\n",
    "# Grid dimension\n",
    "WIDTH, HEIGHT = 500, 500\n",
    "\n",
    "# Grid squaring\n",
    "nb_square_x, nb_square_y = 10, 10\n",
    "grid = CanvasGrid(agent_portrayal, nb_square_x, nb_square_y, WIDTH, HEIGHT) # Initialize grid\n",
    "\n",
    "\n",
    "server = ModularServer(CivModel, # Initialize Server for Model \"CivModel\"\n",
    "\t\t\t\t\t   [grid], \t # Print grids\n",
    "\t\t\t\t\t   \"Dark Forest Model\", # Title\n",
    "\t\t\t\t\t   {\"N\":5, \"width\":10, \"height\":10}) # Declare CivModel arguments\n",
    "\n",
    "server.port = 8521 # Set port\n",
    "server.launch() "
   ]
  },
  {
   "cell_type": "markdown",
   "id": "copyrighted-rwanda",
   "metadata": {},
   "source": [
    "Le résultat n'est pas très excitant, mais il démontre bien ce qu'il est possible de faire en 50 lignes."
   ]
  },
  {
   "cell_type": "markdown",
   "id": "front-mobile",
   "metadata": {},
   "source": [
    "#### version 1"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "derived-coating",
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "from mesa import Agent, Model\n",
    "from mesa.time import RandomActivation\n",
    "from mesa.space import MultiGrid\n",
    "from mesa.datacollection import DataCollector\n",
    "\n",
    "import random\n",
    "from collections import OrderedDict\n",
    "\n",
    "\n",
    "class CivAgent(Agent):\n",
    "    \"\"\" An agent with fixed initial wealth.\"\"\"\n",
    "\n",
    "    def __init__(self, unique_id, model):\n",
    "        super().__init__(unique_id, model)\n",
    "        self.emission = random.randrange(2)  # Capacité à émettre des signaux\n",
    "        # Capacité à recevoir des signaux\n",
    "        self.reception = random.randrange(2)\n",
    "        # Type de civilisation : Pacifique ou Aggressive\n",
    "        self.type = bool(random.getrandbits(1))\n",
    "        self.tech_lvl = random.randrange(10)  # Niveau technologique\n",
    "        # Positions des agents qui ne sont déclarés qu'après les dimensions de la grid\n",
    "        self.x, self.y = None, None\n",
    "        self.pos = None\n",
    "\n",
    "    def step(self):\n",
    "        print(\"Agent\", self.unique_id, \" initialized\",\n",
    "              #\"Emission ability : {}\".format(self.emission),\n",
    "              #\"Reception ability : {}\".format(self.reception),\n",
    "              #\"Tech lvl : {}\".format(self.tech_lvl),\n",
    "              \"Type :\", \"Aggressive\" if self.type else \"Pacifique\")\n",
    "\n",
    "\n",
    "class CivModel(Model):\n",
    "    \"\"\"A model with some number of agents.\"\"\"\n",
    "\n",
    "    def __init__(self, N, width=500, height=500):\n",
    "        self.nb_agents = N\n",
    "        self.grid = MultiGrid(width, height, True)\n",
    "        self.schedule = RandomActivation(self)  # Créer une timeline\n",
    "\n",
    "        for i in range(self.nb_agents):\n",
    "\n",
    "            agent = CivAgent(i, self)\n",
    "            self.schedule.add(agent)  # ajoute N agent à la timeline\n",
    "            # positionne aléatoirement l'agent sur la grille\n",
    "            agent.x = self.random.randrange(self.grid.width)\n",
    "            agent.y = self.random.randrange(self.grid.height)\n",
    "            agent.pos = agent.x, agent.y\n",
    "            self.grid.place_agent(agent, agent.pos)\n",
    "\n",
    "    def random_connect(self):\n",
    "        \"\"\"Renvoie une liste de pair d'agent, dans l'ordre si random=False\"\"\"\n",
    "        random_id = random.sample(\n",
    "            [k for k in range(self.nb_agents)], self.nb_agents)\n",
    "        n_l = [k for k in range(self.nb_agents)]\n",
    "        connection = list(zip(n_l, random_id))\n",
    "        return connection\n",
    "\n",
    "    def contact(self):\n",
    "        \"\"\"Première aspect de la logique utilisé, random_connect crée une \n",
    "            liste de tuple qui relie deux CivAgent entre eux cette fonction compare leur \n",
    "            self.type (0 pour Pacifique (P) et 1 pour aggressif (A)) et leur niveau technologique\n",
    "            (self.tech_lvl) si besoin.\"\"\"\n",
    "\n",
    "        #print(self.schedule._agents[2])\n",
    "        #print(list(self.schedule._agents))\n",
    "        r_l = self.random_connect()\n",
    "        #print(r_l)\n",
    "        for a, b in r_l:\n",
    "            #print(a)\n",
    "\n",
    "            # Si l'agent a deja ete remove, continue\n",
    "            if a in list(self.schedule._agents) and b in list(self.schedule._agents):\n",
    "                agent_a = self.schedule._agents[a]\n",
    "                agent_b = self.schedule._agents[b]\n",
    "            else:\n",
    "                continue\n",
    "\n",
    "            if agent_a.type < agent_b.type:  # Si b A et a P\n",
    "                self.schedule.remove(agent_a)  # remove a\n",
    "                print(\"Agent\", a, \"destroyed by Agent\", b)\n",
    "            elif agent_a.type > agent_b.type:  # Si b P et a A\n",
    "                self.schedule.remove(agent_b)  # remove b\n",
    "                print(\"Agent\", b, \"destroyed by Agent\", a)\n",
    "            elif agent_a.type == 1 and agent_b.type == 1:  # Si b A et a A, regarde le tech_lvl\n",
    "                print(\"Agents\", a, \"and\", b, \"are both aggresive\")\n",
    "                if agent_a.tech_lvl == agent_b.tech_lvl:  # btech == atech <=> b P et a P\n",
    "                    print(a, \"and\", b, \"have the same technological level, nothing appends\")\n",
    "                    continue\n",
    "                elif agent_a.tech_lvl < agent_b.tech_lvl:\n",
    "                    self.schedule.remove(agent_a)\n",
    "                    print(\"Agent\", b ,\"stronger than Agent\", a)\n",
    "                    print(\"Agent\", a, \"destroyed by Agent\", b)\n",
    "                else:\n",
    "                    self.schedule.remove(agent_b)\n",
    "                    print(\"Agent\", a ,\"stronger than Agent\", b)\n",
    "                    print(\"Agent\", b, \"destroyed by Agent\", a)\n",
    "            else:\n",
    "                continue\n",
    "        # Renvoie la liste des agents ayant survécu\n",
    "        survivors = [index for index in list(self.schedule._agents)]\n",
    "        print(\"Survivors:\", survivors)\n",
    "        return survivors\n",
    "\n",
    "    def step(self):\n",
    "        self.schedule.step()\n",
    "        self.contact()\n",
    "\n",
    "def main():\n",
    "    empty_model = CivModel(11)\n",
    "    for i in range(5):\n",
    "        empty_model.step()\n",
    "\n",
    "if __name__ == \"__main__\":\n",
    "    main()"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "fossil-civilization",
   "metadata": {},
   "source": [
    "Premier aspect dynamique ! Ici on se passe totalement de l'espace 2D (qui n'arrivera pas tout de suite) mais on obtient déjà un semblant de résultat.\n",
    "(faire qq courbe + montrer les résultats)"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "pursuant-cigarette",
   "metadata": {},
   "source": [
    "#### version 2"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "indirect-public",
   "metadata": {},
   "source": [
    "On a implémenté un nouveau système pour simulé le repérage des diverses civilisations. On a mis de côté (pour l'instant et, qui sait, peut être pour toujours) la dimension spatial du model, qui, car trop complexe et non nécessaire à l'obtention de résultat concret, n'a pour l'instant pas lieu d'être.\n",
    "À la place on caractérise chaque civilisation par des paramètres ```emission``` et  ```reception```. Chaque civilisations (souvent appelées agents dans les commentaires du codes) ont un niveau d'émission et de réception donné tel que si une civilisation à un petit (resp. grand) niveau d'émission, elle sera plus difficile (resp.plus facile) à repérer. De même, la capacité de réception d'une civilisation représente sa capacité à recevoir/interpréter des signaux. L'implémentation de ces deux paramètres fonctionnent comme suis : \n",
    "\n",
    "Plus le niveau d'emission est haut, moins un niveau de réception haut est nécessaire pour entrer en contact (du moins dans un sens, pour l'instant) à l'inverse plus le niveau d'émission est bas, plus la difficulté à repérer une telle civilisation est grande et donc plus un niveau élevé de reception est nécessaire."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "quality-marks",
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "from mesa import Agent, Model\n",
    "from mesa.time import RandomActivation, BaseScheduler\n",
    "from mesa.space import MultiGrid\n",
    "from mesa.datacollection import DataCollector\n",
    "\n",
    "import random\n",
    "from collections import OrderedDict\n",
    "\n",
    "emission_range = 5\n",
    "reception_range = 5\n",
    "technological_range = 10\n",
    "\n",
    "class CivAgent(Agent):\n",
    "    \"\"\" An agent with fixed initial wealth.\"\"\"\n",
    "\n",
    "    def __init__(self, unique_id, model):\n",
    "        super().__init__(unique_id, model)\n",
    "        self.emission = random.randrange(emission_range)  # Capacité à émettre des signaux\n",
    "        # Capacité à recevoir des signaux\n",
    "        self.reception = random.randrange(reception_range)\n",
    "        # Type de civilisation : Pacifique ou Aggressive\n",
    "        self.type = bool(random.getrandbits(1))\n",
    "        self.tech_lvl = random.randrange(technological_range)  # Niveau technologique\n",
    "        # Positions des agents qui ne sont déclarés qu'après les dimensions de la grid\n",
    "        self.x, self.y = None, None\n",
    "        self.pos = None\n",
    "\n",
    "    def step(self):\n",
    "        print(\"Agent\", self.unique_id, \" initialized\",\n",
    "              \"Emission ability : \", self.emission,\n",
    "              \"Reception ability : \", self.reception,\n",
    "              \"Tech lvl : {}\".format(self.tech_lvl),\n",
    "              \"Type :\", \"Aggressive\" if self.type else \"Pacifique\")\n",
    "\n",
    "\n",
    "class CivModel(Model):\n",
    "    \"\"\"A model with some number of agents.\"\"\"\n",
    "\n",
    "    def __init__(self, N, width=500, height=500):\n",
    "        self.nb_agents = N\n",
    "        self.grid = MultiGrid(width, height, True)\n",
    "        self.schedule = BaseScheduler(self)  # Créer une timeline\n",
    "\n",
    "        for i in range(self.nb_agents):\n",
    "\n",
    "            agent = CivAgent(i, self)\n",
    "            self.schedule.add(agent)  # ajoute N agent à la timeline\n",
    "            # positionne aléatoirement l'agent sur la grille\n",
    "            agent.x = self.random.randrange(self.grid.width)\n",
    "            agent.y = self.random.randrange(self.grid.height)\n",
    "            agent.pos = agent.x, agent.y\n",
    "            self.grid.place_agent(agent, agent.pos)\n",
    "\n",
    "    def random_connect(self, seed=0):\n",
    "        \"\"\"Renvoie une liste de pair d'agent dans l'orde aléatoire\"\"\"\n",
    "        #random.seed(0) # Pas bien !\n",
    "        random_id = random.sample(\n",
    "            [k for k in range(self.nb_agents)], self.nb_agents)\n",
    "        n_l = [k for k in range(self.nb_agents)]\n",
    "        connection = list(zip(n_l, random_id))\n",
    "        print(connection)\n",
    "        return connection\n",
    "\n",
    "    def detect(self, agentA, agentB, both=True):\n",
    "        \"\"\"Renvoie si oui ou non l'agent a detect l'agent b\n",
    "            Fonctionnement du système émission/réception:\n",
    "            Plus un agent émet de signaux, plus il est repérable. Le niveau de reception\n",
    "            définit la capacité d'un agent à détecter des signaux.\n",
    "            Par conséquent plus le niveau d'emission d'un agent est haut plus il\n",
    "            est facilement reperable par des agents dont le niveau de reception est bas.\n",
    "            \"\"\"\n",
    "        if agentA.reception == 0:\n",
    "            return False\n",
    "            print(\"Agent\", self.schedule._agents, \"ne peut rien reperer\") # Cas ou reception = 0, L'agent ne peut rien reperer\n",
    "        else:\n",
    "            # Créé une liste par compréhension dont les élement sont les niveaux d'emissions reperables par l'agent A, \n",
    "            # si l'agent B a un niveau d'emission appartement à cette liste alors A peut reperer B\n",
    "            spotable_agents = [k for k in range(emission_range-1, emission_range-agentA.reception-1, -1)]\n",
    "            print(\"Agent\", agentA.unique_id, \"R\"+str(agentA.reception), \"Agent\", agentB.unique_id, \"E\"+str(agentB.emission), \"l'agent peut reperer ceux dont l'emission est : \", spotable_agents)\n",
    "            return agentB.emission in spotable_agents # renvoie vrai si l'agentB peut etre repere par A ou faux sinon\n",
    "\n",
    "\n",
    "    def contact(self):\n",
    "        \"\"\"Première aspect de la logique utilisé, random_connect crée une \n",
    "            liste de tuple qui relie deux CivAgent entre eux cette fonction compare leur \n",
    "            self.type (0 pour Pacifique (P) et 1 pour aggressif (A)) et leur niveau technologique\n",
    "            (self.tech_lvl) si besoin.\"\"\"\n",
    "\n",
    "        #print(self.schedule._agents[2])\n",
    "        #print(list(self.schedule._agents))\n",
    "        r_l = self.random_connect(0)\n",
    "        #print(r_l)\n",
    "        for a, b in r_l:\n",
    "            #print(a)\n",
    "\n",
    "            # Si l'agent n'appartient déjà plus à self.schedule (qu'il a donc déjà été remove), passe à la prochaine itération\n",
    "            if a in list(self.schedule._agents) and b in list(self.schedule._agents):\n",
    "                agent_a = self.schedule._agents[a]\n",
    "                agent_b = self.schedule._agents[b]\n",
    "\n",
    "                if a == b: # Si A est B, passe\n",
    "                    print(\"Meme agent\")\n",
    "                    continue\n",
    "                elif not self.detect(agent_a, agent_b): # Si A ne detect pas B, vérifie que B ne detect pas A puis passe\n",
    "                    print(\"Agent\", a, \"ne rentre pas en contact avec Agent\", b, \": AR\", agent_a.reception, \"/ BE\", agent_b.emission)\n",
    "                    continue\n",
    "                    if not self.detect(agent_b, agent_a):\n",
    "                        print(\"Agent\", b, \"ne rentre pas en contact avec Agent\", a, \": BR\", agent_b.reception, \"/ AE\", agent_a.emission)\n",
    "                        continue\n",
    "                    else:\n",
    "                        print(\"Mais Agent\", b, \"rentre en contact avec Agent\", a, \": BR\", agent_b.reception, \"/ AE\", agent_a.emission)\n",
    "            else:\n",
    "                continue\n",
    "\n",
    "            print(\"Agents\", a, b, \"entre en contact !\",\n",
    "                \"Agents restant\", list(self.schedule._agents))\n",
    "            if agent_a.type < agent_b.type:  # Si b Aggressif et a Pacifist\n",
    "                self.schedule.remove(agent_a)  # remove a\n",
    "                print(\"Agent\", a, \"destroyed by Agent\", b)\n",
    "            elif agent_a.type > agent_b.type:  # Si b Pacifist et a Aggressif\n",
    "                self.schedule.remove(agent_b)  # remove b\n",
    "                print(\"Agent\", b, \"destroyed by Agent\", a)\n",
    "            elif agent_a.type == 1 and agent_b.type == 1:  # Si b Aggressif et a Aggressif, regarde le tech_lvl\n",
    "                print(\"Agents\", a, \"and\", b, \"are both aggresive\")\n",
    "                if agent_a.tech_lvl == agent_b.tech_lvl:  # Niv technologique B == Niv technologique A <=> b Pacifist et a Pacifist, donc passe\n",
    "                    print(a, \"and\", b, \"have the same technological level, nothing appends\")\n",
    "                    continue\n",
    "                elif agent_a.tech_lvl < agent_b.tech_lvl:# Si B a un meilleur NT que A, B détruit A\n",
    "                    self.schedule.remove(agent_a)\n",
    "                    print(\"Agent\", b ,\"stronger than Agent\", a)\n",
    "                    print(\"Agent\", a, \"destroyed by Agent\", b)\n",
    "                else:\n",
    "                    self.schedule.remove(agent_b) # Same mais inverse\n",
    "                    print(\"Agent\", a ,\"stronger than Agent\", b)\n",
    "                    print(\"Agent\", b, \"destroyed by Agent\", a)\n",
    "            else:\n",
    "                # Cas où les deux agents sont pacifistes et la chaine de suspicion s'engrange, à implémenter\n",
    "                print(\"Agent\", a, \"and\", b, \"are both pacifists -> chaine de suspicion (a implémenté, ne fait rien pour l'instant)\")\n",
    "                if agent_a.tech_lvl == agent_b.tech_lvl:  # Niv technologique B == Niv technologique A <=> b Pacifist et a Pacifist, donc passe\n",
    "                    print(a, \"and\", b, \"have the same technological level, nothing appends\")\n",
    "                    continue\n",
    "                elif agent_a.tech_lvl < agent_b.tech_lvl:# Si B a un meilleur NT que A, B détruit A\n",
    "                    self.schedule.remove(agent_a)\n",
    "                    print(\"Agent\", b ,\"stronger than Agent\", a)\n",
    "                    print(\"Agent\", a, \"destroyed by Agent\", b)\n",
    "                else:\n",
    "                    self.schedule.remove(agent_b) # Same mais inverse\n",
    "                    print(\"Agent\", a ,\"stronger than Agent\", b)\n",
    "                    print(\"Agent\", b, \"destroyed by Agent\", a)\n",
    "                    \n",
    "        # Renvoie la liste des agents ayant survécu\n",
    "        survivors = [index for index in list(self.schedule._agents)]\n",
    "        print(\"Survivors:\")\n",
    "        #affiche les agents restant\n",
    "        self.schedule.step()\n",
    "        return survivors\n",
    "\n",
    "    def step(self):\n",
    "        #self.schedule.step()\n",
    "        self.contact()\n",
    "\n",
    "def main():\n",
    "    empty_model = CivModel(5)\n",
    "    empty_model.schedule.step()\n",
    "    for i in range(5):\n",
    "        print(\"Tour : \" + str(i))\n",
    "        empty_model.step()\n",
    "        print(\"Nombre d'agents restant\", len(empty_model.schedule._agents))\n",
    "    empty_model.step\n",
    "\n",
    "if __name__ == \"__main__\":\n",
    "    main()"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "physical-trinidad",
   "metadata": {},
   "source": [
    "En plus de l'implémentation des paramètres reception/emission, les logs sont plus claires, on peut déjà entrevoir la réponse à plusieurs hypothèses en modifiant les différents paramètres."
   ]
  },
  {
   "cell_type": "markdown",
   "id": "senior-mentor",
   "metadata": {},
   "source": [
    "##### version 3\n",
    "\n",
    "Dans cette troisième version on a implémenté la distance entre les agents, pour l'instant en deux dimensions pour des raisons de rapidité mais il sera très facile de passer à un espace tridimensionnel. On a aussi amélioré l'algorythme (maintenant plus rapide) permettant de déterminer si une civilisation détecte/est détectable par rapport à son niveau d'émission/réception. \n",
    "\n",
    "Fonctionnement de la prise en compte de la distance :\n",
    "\n",
    "On utilise la fonction exponentielle pour simuler la difficulté à communiquer dans l'univers, c'est à dire les différents types d'interférences, les siganux perdus etc... \n",
    "Pour ce faire on utilise la fonction : exp(-kx) où x est la distance séparant deux civilisations et k>0 le facteur \"d'opacité\" de l'univers, plus celui-ci est élevé plus il est difficile, même avec de très bon niveau d'émission et de réception, d'intercepter des signaux compréhensible d'autres ETI.\n",
    "C'est une manière simple est assez efficace de représenter les différents aléas de l'immensité cosmique qui interviennent dans la tentative de communication (voir sources)."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "chicken-correspondence",
   "metadata": {},
   "outputs": [],
   "source": [
    "\n",
    "from mesa import Agent, Model\n",
    "from mesa.time import RandomActivation, BaseScheduler\n",
    "from mesa.space import MultiGrid\n",
    "from mesa.datacollection import DataCollector\n",
    "\n",
    "import random\n",
    "import math\n",
    "from collections import OrderedDict\n",
    "\n",
    "emission_range = 5\n",
    "reception_range = 5\n",
    "technological_range = 10\n",
    "univers_scale = 1000\n",
    "opacity_factor = 1\n",
    "threshold = 0.001\n",
    "# random.seed(0)\n",
    "\n",
    "class CivAgent(Agent):\n",
    "    \"\"\" An agent with fixed initial wealth.\"\"\"\n",
    "\n",
    "    def __init__(self, unique_id, model):\n",
    "        super().__init__(unique_id, model)\n",
    "        # Capacité à émettre des signaux\n",
    "        self.emission = random.randrange(emission_range)\n",
    "        # Capacité à recevoir des signaux\n",
    "        self.reception = random.randrange(reception_range)\n",
    "        # Type de civilisation : Pacifique ou Aggressive\n",
    "        self.type = bool(random.getrandbits(1))\n",
    "        self.tech_lvl = random.randrange(technological_range) \n",
    "        # Niveau technologique\n",
    "        # Positions des agents qui ne sont déclarés qu'après les dimensions de la grid\n",
    "        self.x, self.y = random.randrange(1000), random.randrange(1000)\n",
    "        self.pos = self.x, self.y\n",
    "\n",
    "    def step(self):\n",
    "        print(\"Agent\", self.unique_id, \" initialized\",\n",
    "              \"Emission ability : \", self.emission,\n",
    "              \"Reception ability : \", self.reception,\n",
    "              \"Tech lvl : \", self.tech_lvl,\n",
    "              \"Type :\", \"Aggressive\" if self.type else \"Pacifique\")\n",
    "\n",
    "\n",
    "class CivModel(Model):\n",
    "    \"\"\"A model with some number of agents.\"\"\"\n",
    "\n",
    "    def __init__(self, N):\n",
    "        self.nb_agents = N\n",
    "        self.schedule = BaseScheduler(self)  # Créer une timeline\n",
    "\n",
    "        for i in range(self.nb_agents):\n",
    "            agent = CivAgent(i, self)\n",
    "            self.schedule.add(agent)  # ajoute N agent à la timeline\n",
    "            # positionne aléatoirement l'agent sur la grille\n",
    "\n",
    "        self.distances_log = self.calculate_distance()\n",
    "\n",
    "    def random_connect(self, methodeTheo=False, seed=0):\n",
    "        \"\"\"Renvoie une liste de pair d'agent dans l'orde aléatoire\"\"\"\n",
    "        #random.seed(0) # Pas bien !\n",
    "        random_id = random.sample(\n",
    "            [k for k in range(len(list(self.schedule._agents)))], len(list(self.schedule._agents)))\n",
    "        n_l = list(range(len(list(self.schedule._agents))))\n",
    "        connection = list(zip(n_l, random_id))\n",
    "        print(connection)\n",
    "        return connection\n",
    "\n",
    "    def calculate_distance(self):\n",
    "        distances_log = {}\n",
    "        for i in self.schedule._agents:\n",
    "            #print(distances_log, len(distances_log))\n",
    "            if i in self.schedule._agents.keys():\n",
    "                agentA = self.schedule._agents[i]\n",
    "                for j in range(i+1, len(self.schedule._agents)):\n",
    "                    if j in self.schedule._agents.keys():\n",
    "                        agentB = self.schedule._agents[j]\n",
    "                        d = math.sqrt((agentA.x-agentB.x)**2+(agentA.y-agentB.y)**2)\n",
    "                        distances_log[(i, j)] = d\n",
    "        return distances_log\n",
    "\n",
    "    def detect_distance_check(self, distance, opacity_factor, threshold):\n",
    "        d_scaled = distance/univers_scale\n",
    "        return math.exp(-opacity_factor*d_scaled)\n",
    "\n",
    "    def detect(self, agentA, agentB, both=True):\n",
    "        \"\"\"Renvoie si oui ou non l'agent a detect l'agent b\n",
    "            Fonctionnement du système émission/réception:\n",
    "            Plus un agent émet de signaux, plus il est repérable. Le niveau de reception\n",
    "            définit la capacité d'un agent à détecter des signaux.\n",
    "            Par conséquent plus le niveau d'emission d'un agent est haut plus il\n",
    "            est facilement reperable par des agents dont le niveau de reception est bas.\n",
    "            \"\"\"\n",
    "        if agentA.reception == 0:\n",
    "            return False\n",
    "            # Cas ou reception = 0, L'agent ne peut rien reperer\n",
    "            print(\"Agent\", self.schedule._agents, \"ne peut rien reperer\")\n",
    "        else:\n",
    "            a = self.detect_distance_check(self.distances_log[(min(agentA.unique_id, agentB.unique_id), max(agentA.unique_id, agentB.unique_id))], opacity_factor, threshold)\n",
    "            print(self.distances_log[(min(agentA.unique_id, agentB.unique_id), max(agentA.unique_id, agentB.unique_id))], a, threshold)\n",
    "            if not a >= threshold:\n",
    "                print(\"Trop loin...\")\n",
    "                \n",
    "            return agentA.reception + agentB.emission >= reception_range+1 and a >= threshold# max(R) + 1\n",
    "\n",
    "    def contact(self):\n",
    "        \"\"\"Première aspect de la logique utilisé, random_connect crée une\n",
    "            liste de tuple qui relie deux CivAgent entre eux cette fonction compare leur\n",
    "            self.type (0 pour Pacifique (P) et 1 pour aggressif (A)) et leur niveau technologique\n",
    "            (self.tech_lvl) si besoin.\"\"\"\n",
    "\n",
    "        # print(self.schedule._agents[2])\n",
    "        # print(list(self.schedule._agents))\n",
    "        r_l = self.random_connect()\n",
    "        # print(r_l)\n",
    "        for a, b in r_l:\n",
    "            # print(a)\n",
    "\n",
    "            # Si l'agent n'appartient déjà plus à self.schedule (qu'il a donc déjà été remove), passe à la prochaine itération\n",
    "            if a in list(self.schedule._agents) and b in list(self.schedule._agents):\n",
    "                agent_a = self.schedule._agents[a]\n",
    "                agent_b = self.schedule._agents[b]\n",
    "\n",
    "                if a == b:  # Si A est B, passe\n",
    "                    print(\"Meme agent\")\n",
    "                    continue\n",
    "                # Si A ne detect pas B, vérifie que B ne detect pas A puis passe\n",
    "                elif not self.detect(agent_a, agent_b):\n",
    "                    print(\"Agent\", a, \"ne rentre pas en contact avec Agent\",\n",
    "                          b, \": AR\", agent_a.reception, \"/ BE\", agent_b.emission)\n",
    "                    continue\n",
    "                    if not self.detect(agent_b, agent_a):\n",
    "                        print(\"Agent\", b, \"ne rentre pas en contact avec Agent\",\n",
    "                              a, \": BR\", agent_b.reception, \"/ AE\", agent_a.emission)\n",
    "                        continue\n",
    "                    else:\n",
    "                        print(\"Mais Agent\", b, \"rentre en contact avec Agent\",\n",
    "                              a, \": BR\", agent_b.reception, \"/ AE\", agent_a.emission)\n",
    "            else:\n",
    "                continue\n",
    "\n",
    "            print(\"Agents\", a, b, \"entre en contact !\",\n",
    "                \"Agents restant\", list(self.schedule._agents))\n",
    "            if agent_a.type < agent_b.type:  # Si b Aggressif et a Pacifist\n",
    "                self.schedule.remove(agent_a)  # remove a\n",
    "                print(\"Agent\", a, \"destroyed by Agent\", b)\n",
    "            elif agent_a.type > agent_b.type:  # Si b Pacifist et a Aggressif\n",
    "                self.schedule.remove(agent_b)  # remove b\n",
    "                print(\"Agent\", b, \"destroyed by Agent\", a)\n",
    "            elif agent_a.type == 1 and agent_b.type == 1:  # Si b Aggressif et a Aggressif, regarde le tech_lvl\n",
    "                print(\"Agents\", a, \"and\", b, \"are both aggresive\")\n",
    "                # Niv technologique B == Niv technologique A <=> b Pacifist et a Pacifist, donc passe\n",
    "                if agent_a.tech_lvl == agent_b.tech_lvl:\n",
    "                    print(a, \"and\", b,\n",
    "                          \"have the same technological level, nothing appends\")\n",
    "                    continue\n",
    "                elif agent_a.tech_lvl < agent_b.tech_lvl:  # Si B a un meilleur NT que A, B détruit A\n",
    "                    self.schedule.remove(agent_a)\n",
    "                    print(\"Agent\", b, \"stronger than Agent\", a)\n",
    "                    print(\"Agent\", a, \"destroyed by Agent\", b)\n",
    "                else:\n",
    "                    self.schedule.remove(agent_b)  # Same mais inverse\n",
    "                    print(\"Agent\", a, \"stronger than Agent\", b)\n",
    "                    print(\"Agent\", b, \"destroyed by Agent\", a)\n",
    "            else:\n",
    "                # Cas où les deux agents sont pacifistes et la chaine de suspicion s'engrange, à implémenter\n",
    "                print(\"Agent\", a, \"and\", b,\n",
    "                      \"are both pacifists -> chaine de suspicion (a implémenté, ne fait rien pour l'instant)\")\n",
    "                # Niv technologique B == Niv technologique A <=> b Pacifist et a Pacifist, donc passe\n",
    "                if agent_a.tech_lvl == agent_b.tech_lvl:\n",
    "                    print(a, \"and\", b,\n",
    "                          \"have the same technological level, nothing appends\")\n",
    "                    continue\n",
    "                elif agent_a.tech_lvl < agent_b.tech_lvl:  # Si B a un meilleur NT que A, B détruit A\n",
    "                    self.schedule.remove(agent_a)\n",
    "                    print(\"Agent\", b, \"stronger than Agent\", a)\n",
    "                    print(\"Agent\", a, \"destroyed by Agent\", b)\n",
    "                else:\n",
    "                    self.schedule.remove(agent_b)  # Same mais inverse\n",
    "                    print(\"Agent\", a, \"stronger than Agent\", b)\n",
    "                    print(\"Agent\", b, \"destroyed by Agent\", a)\n",
    "\n",
    "        # Renvoie la liste des agents ayant survécu\n",
    "        survivors = [index for index in list(self.schedule._agents)]\n",
    "        print(\"Survivors:\")\n",
    "        # affiche les agents restant\n",
    "        # self.schedule.step()\n",
    "        return survivors\n",
    "\n",
    "    def step(self):\n",
    "        #self.schedule.step()\n",
    "        self.calculate_distance()\n",
    "        self.contact()\n",
    "\n",
    "def main():\n",
    "    model = CivModel(1000)\n",
    "    model.step()\n",
    "    for i in range(100):\n",
    "        print(\"Tour : \", i)\n",
    "        model.step()\n",
    "        print(\"Nombre d'agents restant\", len(model.schedule._agents))\n",
    "\n",
    "\n",
    "if __name__ == \"__main__\":\n",
    "    main()\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "dynamic-jewel",
   "metadata": {},
   "source": [
    "Petite section résultat serait appréciée"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "purple-macedonia",
   "metadata": {},
   "source": [
    "##### Version 4\n",
    "\n",
    "Dans cette version on a implémenté plusieurs nouveaux éléments. Dans un premier temps une (très légère) interface visuelle a été ajouté : on peut désormais voir qu'elles civilisations on résisté en fonction de leur position dans un espace 2D. Ensuite, on a ajouté des \"clusters\", la matière dans l'univers n'étant pas répartit uniformément, mais par petites zone éloignée les unes de autres, on a implémenté des zones de rayon restreint dans lesquels sont placées les civilisations à l'initialisation du modèl (voir photo + source). Un nouveau mode de connection à aussi été implémenté, le mode \"nearest neighbors\" dans lequel les connections ne sont pas faites aléatoirement comme dans les versions antérieures mais avec le voisins le plus proches. Pour ce faire on a calculé et classé par ordre décroissant l'intégralité des distances entre les agents. La composante z a aussi été ajouté. Petit point sur les résultats."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "dried-lobby",
   "metadata": {},
   "outputs": [],
   "source": [
    "from mesa import Agent, Model\n",
    "from mesa.time import RandomActivation, BaseScheduler\n",
    "from mesa.space import MultiGrid\n",
    "from mesa.datacollection import DataCollector\n",
    "\n",
    "from tkinter import *\n",
    "import random\n",
    "import math\n",
    "#from collections import OrderedDict\n",
    "\n",
    "##### TKINTER PARAMETERS & INITIALIZATION #####\n",
    "\n",
    "H = 500\n",
    "W = 500\n",
    "\n",
    "#\n",
    "\n",
    "window = Tk()\n",
    "canvas = Canvas(window, width=W, height=H, bg='black')\n",
    "canvas.pack()\n",
    "\n",
    "###############################################\n",
    "\n",
    "##### IMPORTANT PARAMETERS #####\n",
    "\n",
    "# AGENT PARAMETERS\n",
    "emission_range = 5\n",
    "reception_range = 5\n",
    "technological_range = 10\n",
    "\n",
    "# UNIVERS PARAMETER\n",
    "univers_scale = 500\n",
    "opacity_factor = 1\n",
    "threshold = 0.001\n",
    "nb_clusters = 3\n",
    "clusters_scale = 100\n",
    "\n",
    "################################\n",
    "# random.seed(0)\n",
    "\n",
    "\n",
    "class CivAgent(Agent):\n",
    "\n",
    "    def __init__(self, unique_id, model):\n",
    "\n",
    "        super().__init__(unique_id, model)\n",
    "\n",
    "        # Caracteristic\n",
    "        self.emission = random.randrange(emission_range)\n",
    "        self.reception = random.randrange(reception_range)\n",
    "        self.type = bool(random.getrandbits(1))\n",
    "        self.tech_lvl = random.randrange(technological_range)\n",
    "\n",
    "        # Coordinates\n",
    "        self.x = None\n",
    "        self.y = None\n",
    "        self.z = None  # for 3D\n",
    "\n",
    "    def step(self):\n",
    "\n",
    "        print(\"Agent\", self.unique_id, \" initialized\",\n",
    "              \"Emission ability : \", self.emission,\n",
    "              \"Reception ability : \", self.reception,\n",
    "              \"Tech lvl : \", self.tech_lvl,\n",
    "              \"Type :\", \"Aggressive\" if self.type else \"Pacifique\")\n",
    "\n",
    "    def activate_suspicion(self, agent_id):\n",
    "        self.suspicious = 1, agent_id\n",
    "\n",
    "\n",
    "class CivModel(Model):\n",
    "\n",
    "    def __init__(self, N):\n",
    "\n",
    "        self.nb_agents = N  # Nombre d'agents\n",
    "        self.schedule = BaseScheduler(self)  # Timeline basic\n",
    "\n",
    "        # Initializations spatials des agents\n",
    "        positions = self.spawn_clusters()\n",
    "        #print(positions, len(positions))\n",
    "\n",
    "        for i in range(self.nb_agents):\n",
    "            # positionne aléatoirement l'agent sur la grille\n",
    "            agent = CivAgent(i, self)\n",
    "            agent.x, agent.y, agent.z = positions[i]\n",
    "            self.schedule.add(agent)  # ajoute les agents à la timeline\n",
    "\n",
    "        # Calcules les distances entre les agents\n",
    "        self.distances_log = self.calculate_distance()\n",
    "\n",
    "    def spawn_clusters(self):\n",
    "        \"\"\"Répartis les civilisations en clusters de densité égale \n",
    "           dans l'univers (peut être assimiler à des galaxies)\"\"\"\n",
    "        coords = []\n",
    "\n",
    "        for i in range(nb_clusters):\n",
    "            clx, cly, clz = random.randint(0, univers_scale), random.randint(\n",
    "                0, univers_scale), random.randint(0, univers_scale)  # Créer un point de cluster\n",
    "\n",
    "            # Créé un nombres de groupe d'agent équivalent à celui des clusters\n",
    "            rd_nb_civ = int(self.nb_agents/nb_clusters)+1\n",
    "            # Répartis aléatoiremnt les civilisations autour de ce clusters dans un radius donné.\n",
    "            for j in range(rd_nb_civ):\n",
    "                r = clusters_scale\n",
    "                pl_x, pl_y, pl_z = random.randint(max(\n",
    "                    0, clx-r), min(univers_scale, clx+r)), random.randint(max(0, cly-r), min(univers_scale, cly+r)), random.randint(max(0, clz-r), min(univers_scale, clz+r))\n",
    "                coords.append((pl_x, pl_y, pl_z))\n",
    "        return coords\n",
    "\n",
    "    def random_connect(self, methodeTheo=False, seed=0):\n",
    "        \"\"\"Renvoie une liste de pair d'agent dans l'orde aléatoire\"\"\"\n",
    "        # random.seed(0) # Pas bien !\n",
    "        random_id = random.sample(\n",
    "            [k for k in range(len(list(self.schedule._agents)))], len(list(self.schedule._agents)))\n",
    "        n_l = list(range(len(list(self.schedule._agents))))\n",
    "        connection = list(zip(n_l, random_id))\n",
    "        # print(connection)\n",
    "        return connection\n",
    "\n",
    "    def sort_dict(self, dic, first_term=False):\n",
    "        sorted_dict = {}\n",
    "        if first_term:\n",
    "            for i in range(self.nb_agents):\n",
    "                sorted_dict.update({k: v for k,\n",
    "                                    v in sorted(dic.items(), key=lambda item: item[1]) if i is k[0]})\n",
    "        else:\n",
    "            sorted_dict = {k: v for k, v in sorted(\n",
    "                dic.items(), key=lambda item: item[1])}\n",
    "        return sorted_dict\n",
    "\n",
    "    def nn_connect(self):\n",
    "        \"\"\"Connect chaque agent avec les autres en partant du plus proches\"\"\"\n",
    "        distances_dict = self.calculate_distance()\n",
    "        for i in range(self.nb_agents):\n",
    "            order_of_connection = self.sort_dict(distances_dict)\n",
    "        # print(order_of_connection)\n",
    "        return order_of_connection.keys()\n",
    "\n",
    "    def calculate_distance(self):\n",
    "        \"\"\"Créé un dictionnaire dont les keys sont la pair d'agent en question la la value la distance les séparant\"\"\"\n",
    "        distances_log = {}\n",
    "        for i in self.schedule._agents:\n",
    "            #print(distances_log, len(distances_log))\n",
    "            if i in self.schedule._agents.keys():\n",
    "                agentA = self.schedule._agents[i]\n",
    "                for j in range(i+1, len(self.schedule._agents)):\n",
    "                    if j in self.schedule._agents.keys():\n",
    "                        agentB = self.schedule._agents[j]\n",
    "                        d = math.sqrt((agentA.x-agentB.x)**2 +\n",
    "                                      (agentA.y-agentB.y)**2 + (agentA.z-agentB.z)**2)\n",
    "                        distances_log[(i, j)] = d\n",
    "        return distances_log\n",
    "\n",
    "    def detect_distance_check(self, distance, opacity_factor, threshold):\n",
    "        \"\"\"Utilise la fonction exp(-kx) pour simuler la difficulté des civilisations \n",
    "            à communiquer par rapport à la distance qui les sépare\"\"\"\n",
    "        d_scaled = distance/univers_scale\n",
    "        return math.exp(-opacity_factor*d_scaled)\n",
    "\n",
    "    def detect(self, agentA, agentB, both=True):\n",
    "        \"\"\"Renvoie si oui ou non l'agent a detect l'agent b\n",
    "            Fonctionnement du système émission/réception:\n",
    "            Plus un agent émet de signaux, plus il est repérable. Le niveau de reception\n",
    "            définit la capacité d'un agent à détecter des signaux.\n",
    "            Par conséquent plus le niveau d'emission d'un agent est haut plus il\n",
    "            est facilement reperable par des agents dont le niveau de reception est bas.\n",
    "            \"\"\"\n",
    "        if agentA.reception == 0:\n",
    "            return False\n",
    "            # Cas ou reception = 0, L'agent ne peut rien reperer\n",
    "            print(\"Agent\", self.schedule._agents, \"ne peut rien reperer\")\n",
    "        else:\n",
    "            a = self.detect_distance_check(self.distances_log[(min(agentA.unique_id, agentB.unique_id), max(\n",
    "                agentA.unique_id, agentB.unique_id))], opacity_factor, threshold)\n",
    "            print(self.distances_log[(min(agentA.unique_id, agentB.unique_id), max(\n",
    "                agentA.unique_id, agentB.unique_id))], a, threshold)\n",
    "            if not a >= threshold:\n",
    "                print(\"Trop loin...\")\n",
    "\n",
    "            # max(Reception) + 1, merci Théo\n",
    "            return agentA.reception + agentB.emission >= reception_range+1 and a >= threshold\n",
    "\n",
    "    def remove_store(self, agent_id, storage):\n",
    "        storage.append(self.schedule._agents[agent_id])\n",
    "        self.schedule.remove(agent_id, storage)\n",
    "        return storage\n",
    "\n",
    "    def contact(self):\n",
    "        \"\"\"Première aspect de la logique utilisé, random_connect crée une\n",
    "            liste de tuple qui relie deux CivAgent entre eux cette fonction compare leur\n",
    "            self.type (0 pour Pacifique (P) et 1 pour aggressif (A)) et leur niveau technologique\n",
    "            (self.tech_lvl) si besoin.\"\"\"\n",
    "\n",
    "        # print(self.schedule._agents[2])\n",
    "        # print(list(self.schedule._agents))\n",
    "        r_l = self.nn_connect()\n",
    "        # print(r_l)\n",
    "        for a, b in r_l:\n",
    "            # print(a)\n",
    "\n",
    "            # Si l'agent n'appartient déjà plus à self.schedule (qu'il a donc déjà été remove), passe à la prochaine itération\n",
    "            if a in list(self.schedule._agents) and b in list(self.schedule._agents):\n",
    "                agent_a = self.schedule._agents[a]\n",
    "                agent_b = self.schedule._agents[b]\n",
    "\n",
    "                if a == b:  # Si A est B, passe\n",
    "                    print(\"Meme agent\")\n",
    "                    continue\n",
    "                # Si A ne detect pas B, vérifie que B ne detect pas A puis passe\n",
    "                elif not self.detect(agent_a, agent_b):\n",
    "                    print(\"Agent\", a, \"ne rentre pas en contact avec Agent\",\n",
    "                          b, \": AR\", agent_a.reception, \"/ BE\", agent_b.emission)\n",
    "                    continue\n",
    "                    if not self.detect(agent_b, agent_a):\n",
    "                        print(\"Agent\", b, \"ne rentre pas en contact avec Agent\",\n",
    "                              a, \": BR\", agent_b.reception, \"/ AE\", agent_a.emission)\n",
    "                        continue\n",
    "                    else:\n",
    "                        print(\"Mais Agent\", b, \"rentre en contact avec Agent\",\n",
    "                              a, \": BR\", agent_b.reception, \"/ AE\", agent_a.emission)\n",
    "            else:\n",
    "                continue\n",
    "\n",
    "            print(\"Agents\", a, b, \"entre en contact !\",)\n",
    "            if agent_a.type < agent_b.type:  # Si b Aggressif et a Pacifist\n",
    "                self.schedule.remove(agent_a)  # remove a\n",
    "                print(\"Agent\", a, \"destroyed by Agent\", b)\n",
    "            elif agent_a.type > agent_b.type:  # Si b Pacifist et a Aggressif\n",
    "                self.schedule.remove(agent_b)  # remove b\n",
    "                print(\"Agent\", b, \"destroyed by Agent\", a)\n",
    "            elif agent_a.type == 1 and agent_b.type == 1:  # Si b Aggressif et a Aggressif, regarde le tech_lvl\n",
    "                print(\"Agents\", a, \"and\", b, \"are both aggresive\")\n",
    "                # Niv technologique B == Niv technologique A <=> b Pacifist et a Pacifist, donc passe\n",
    "                if agent_a.tech_lvl == agent_b.tech_lvl:\n",
    "                    print(a, \"and\", b,\n",
    "                          \"have the same technological level, nothing appends\")\n",
    "                    continue\n",
    "                elif agent_a.tech_lvl < agent_b.tech_lvl:  # Si B a un meilleur NT que A, B détruit A\n",
    "                    self.schedule.remove(agent_a)\n",
    "                    print(\"Agent\", b, \"stronger than Agent\", a)\n",
    "                    print(\"Agent\", a, \"destroyed by Agent\", b)\n",
    "                else:\n",
    "                    self.schedule.remove(agent_b)  # Same mais inverse\n",
    "                    print(\"Agent\", a, \"stronger than Agent\", b)\n",
    "                    print(\"Agent\", b, \"destroyed by Agent\", a)\n",
    "            else:\n",
    "                # Cas où les deux agents sont pacifistes et la chaine de suspicion s'engrange, à implémenter\n",
    "                print(\"Agent\", a, \"and\", b,\n",
    "                      \"are both pacifists -> chaine de suspicion (a implémenté, ne fait rien pour l'instant)\")\n",
    "                # Niv technologique B == Niv technologique A <=> b Pacifist et a Pacifist, donc passe\n",
    "                if agent_a.tech_lvl == agent_b.tech_lvl:\n",
    "                    print(a, \"and\", b,\n",
    "                          \"have the same technological level, nothing appends\")\n",
    "                    continue\n",
    "                elif agent_a.tech_lvl < agent_b.tech_lvl:  # Si B a un meilleur NT que A, B détruit A\n",
    "                    self.schedule.remove(agent_a)\n",
    "                    print(\"Agent\", b, \"stronger than Agent\", a)\n",
    "                    print(\"Agent\", a, \"destroyed by Agent\", b)\n",
    "                else:\n",
    "                    self.schedule.remove(agent_b)  # Same mais inverse\n",
    "                    print(\"Agent\", a, \"stronger than Agent\", b)\n",
    "                    print(\"Agent\", b, \"destroyed by Agent\", a)\n",
    "\n",
    "        # Renvoie la liste des agents ayant survécu\n",
    "        survivors = [index for index in list(self.schedule._agents)]\n",
    "        print(\"Survivors:\")\n",
    "        # affiche les agents restant\n",
    "        self.schedule.step()\n",
    "        return survivors\n",
    "\n",
    "    def step(self):\n",
    "        # self.schedule.step()\n",
    "        self.calculate_distance()\n",
    "        self.contact()\n",
    "\n",
    "\n",
    "def main():\n",
    "    N = 100\n",
    "    model = CivModel(N)\n",
    "    # print(model.nn_connect())\n",
    "    model.step()\n",
    "    draw(canvas, model.schedule._agents, 'white')\n",
    "\n",
    "    for i in range(1000):\n",
    "        print(\"Tour : \", i)\n",
    "        model.step()\n",
    "        print(\"Nombre d'agents restant\", len(model.schedule._agents))\n",
    "\n",
    "    draw(canvas, model.schedule._agents, 'green')\n",
    "    model.schedule.step()\n",
    "    window.mainloop()  # Visualize!\n",
    "\n",
    "\n",
    "def draw(canvas, agents_list, color):\n",
    "    for agent in agents_list.values():\n",
    "        canvas.create_oval(agent.x, agent.y, agent.x +\n",
    "                           10, agent.y+10, fill=color)\n",
    "\n",
    "\n",
    "if __name__ == \"__main__\":\n",
    "    main()"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.8.5"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
